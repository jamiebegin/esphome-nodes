substitutions:
  name: esp32-humidifier
  friendly_name: "Humidifier Control"
  area: "Mechanicals"
  ip_addr: 192.168.4.20
  bme680_temperature_offset: "0.0"
  board: "featheresp32"

esp32:
  board: ${board}
  framework:
    type: arduino

esphome:
  includes:
    - dewpoint.h

# ---- HA connectivity guards ----
api:
  # Seed initial state once HA is up; also restore fan mode if we shut down during HA loss
  on_client_connected:
    then:
      - text_sensor.template.publish:
          id: humidifier_status
          state: "off"
      - delay: 5s
      - lambda: |-
          if (!isnan(id(familyroom_humid).state))
            id(indoor_humid).publish_state(id(familyroom_humid).state);
          if (!isnan(id(familyroom_temp).state))
            id(indoor_temp).publish_state(id(familyroom_temp).state);
      # If we powered down during HA loss, restore the fan mode now that HA is back
      - if:
          condition:
            lambda: 'return id(restore_fan_pending);'
          then:
            - logger.log: "HA reconnected; restoring prior fan mode."
            - homeassistant.service:
                service: climate.set_fan_mode
                data:
                  entity_id: climate.main_floor
                  fan_mode: !lambda 'return id(prev_fan_mode).c_str();'
            - lambda: 'id(restore_fan_pending) = false;'

  # If HA drops while steaming, stop immediately to prevent runaway
  on_client_disconnected:
    then:
      - logger.log: "HA disconnected; failsafe shutting down humidifier."
      - if:
          condition:
            or:
              - text_sensor.state: { id: humidifier_status, state: "on" }
              - text_sensor.state: { id: humidifier_status, state: "starting" }
          then:
            - switch.turn_off: call_humid
            - text_sensor.template.publish:
                id: humidifier_status
                state: "ha_lost"
            - lambda: 'id(restore_fan_pending) = true;'

# ------------- Globals -------------
globals:
  - id: prev_fan_mode
    type: std::string
    restore_value: no
    initial_value: "\"auto\""
  - id: restore_fan_pending
    type: bool
    restore_value: no
    initial_value: "false"

# ------------- Switches & Buttons -------------
switch:
  - platform: template
    id: require_heat
    name: "Require Furnace Heat Mode"
    optimistic: true
    icon: "mdi:heat-wave"
    restore_mode: "ALWAYS_ON"

  - platform: template
    id: avoid_condensation
    name: "Avoid Window Condensation"
    optimistic: true
    icon: "mdi:snowflake-melt"
    restore_mode: "ALWAYS_ON"
    turn_on_action:
      - logger.log: "Avoid Window Condensation ON"
      - script.execute:
          id: update_max_throttled_humid
          indoor_temp: !lambda "return float(id(indoor_temp).state);"
          outdoor_temp: !lambda "return float(id(outdoor_temp).state);"
          r_val: !lambda "return float(id(r_value).state);"
    turn_off_action:
      - logger.log: "Avoid Window Condensation OFF"
      - script.execute:
          id: update_max_throttled_humid
          indoor_temp: !lambda "return float(id(indoor_temp).state);"
          outdoor_temp: !lambda "return float(id(outdoor_temp).state);"
          r_val: !lambda "return float(id(r_value).state);"

  - platform: template
    id: pause_humid
    icon: "mdi:pause-box"
    name: "Pause Humidifier"
    restore_mode: "RESTORE_DEFAULT_OFF"
    optimistic: true
    turn_on_action:
      - logger.log: "Humidifier paused"
      - if:
          condition:
            or:
              - text_sensor.state: { id: humidifier_status, state: "on" }
              - text_sensor.state: { id: humidifier_status, state: "starting" }
          then:
            - script.execute: shutdown_steam_and_fan_runout
    turn_off_action:
      - logger.log: "Humidifier unpaused"

  - platform: gpio
    id: call_humid
    pin: 26
    name: "Call Humidity"
    internal: true
    on_turn_on:
      - text_sensor.template.publish:
          id: humidifier_status
          state: "on"
      - logger.log: "HUMIDIFIER STEAM ON"
    on_turn_off:
      - logger.log: "HUMIDIFIER STEAM OFF"

button:
  - platform: template
    id: toggle_steam
    name: "Toggle Steam"
    icon: mdi:waves-arrow-up
    on_press:
      - if:
          condition:
            or:
              - text_sensor.state: { id: humidifier_status, state: 'starting' }
              - text_sensor.state: { id: humidifier_status, state: 'stopping' }
          then:
            - logger.log: "Toggle ignored: transition in progress."
          else:
            - if:
                condition:
                  text_sensor.state: { id: humidifier_status, state: 'off' }
                then:
                  - if:
                      condition:
                        or:
                          - switch.is_on: pause_humid
                          - and:
                              - switch.is_on: require_heat
                              - binary_sensor.is_off: heat_mode_satisfied
                          - binary_sensor.is_off: ha_connected    # <- block starts while HA is down
                      then:
                        - logger.log: "Start suppressed: paused, heat mode not satisfied, or HA offline."
                      else:
                        - text_sensor.template.publish:
                            id: humidifier_status
                            state: "starting"
                        - logger.log: "Setting furnace fan mode to on."
                        - lambda: |-
                            id(prev_fan_mode) = id(fan_mode).state.c_str();  // save current mode
                        - homeassistant.service:
                            service: climate.set_fan_mode
                            data:
                              entity_id: climate.main_floor
                              fan_mode: "on"
                        - wait_until:
                            condition:
                              binary_sensor.is_on: fan_running
                            timeout: 60s
                        - if:
                            condition:
                              binary_sensor.is_off: fan_running
                            then:
                              - text_sensor.template.publish:
                                  id: humidifier_status
                                  state: "fan_error"
                              - logger.log: "Furnace fan timed out."
                              - homeassistant.service:
                                  service: persistent_notification.create
                                  data:
                                    title: "Humidifier"
                                    message: "Furnace fan timed-out while trying to humidify."
                              - switch.turn_off: call_humid
                            else:
                              - logger.log: "Fan on. Waiting 60 secs to spin up."
                              - delay: 60s
                              - switch.turn_on: call_humid
                else:
                  - script.execute: shutdown_steam_and_fan_runout

# ------------- Binary sensors -------------
binary_sensor:
  # HA connection state (internal) — used for gating & restore decisions
  - platform: status
    id: ha_connected
    internal: true

  - platform: template
    id: heat_mode_satisfied
    internal: true

  - platform: template
    id: fan_running
    internal: true

# ------------- Sensors -------------
sensor:
  - platform: mqtt_subscribe
    name: "Humidity Hysteresis"
    id: humid_hysteresis
    topic: esphome/devices/${name}/humidity/hysteresis
    state_class: "measurement"
    device_class: "humidity"
    unit_of_measurement: "%"
    qos: 2
    on_value:
      - logger.log: "Humidity hysteresis adjusted."
      - script.execute:
          id: update_max_throttled_humid
          indoor_temp: !lambda "return float(id(indoor_temp).state);"
          outdoor_temp: !lambda "return float(id(outdoor_temp).state);"
          r_val: !lambda "return float(id(r_value).state);"
      - script.execute:
          id: eval_humid
          current_humid: !lambda "return float(id(indoor_humid).state);"

  - platform: mqtt_subscribe
    name: "Humidity Setpoint"
    id: humid_setpoint
    device_class: "humidity"
    state_class: "measurement"
    unit_of_measurement: "%"
    topic: esphome/devices/${name}/humidity/setpoint
    qos: 2
    on_value:
      - logger.log: "Humidity setpoint adjusted."
      - script.execute:
          id: update_max_throttled_humid
          indoor_temp: !lambda "return float(id(indoor_temp).state);"
          outdoor_temp: !lambda "return float(id(outdoor_temp).state);"
          r_val: !lambda "return float(id(r_value).state);"
      - script.execute:
          id: eval_humid
          current_humid: !lambda "return float(id(indoor_humid).state);"

  - platform: template
    id: humid_setpoint_adjusted
    name: "Adjusted Humidity Setpoint"
    icon: "mdi:water-percent-alert"
    unit_of_measurement: "%"
    device_class: "humidity"
    state_class: "measurement"

  - platform: mqtt_subscribe
    name: "Window R-Value"
    id: r_value
    topic: esphome/devices/${name}/r_value
    qos: 2
    state_class: "measurement"
    on_value:
      - logger.log: "Window R-Value adjusted."
      - script.execute:
          id: update_max_throttled_humid
          indoor_temp: !lambda "return float(id(indoor_temp).state);"
          outdoor_temp: !lambda "return float(id(outdoor_temp).state);"
          r_val: !lambda "return float(x);"

  - platform: homeassistant
    id: outdoor_temp
    entity_id: !secret weather_sensor
    attribute: temperature
    on_value:
      - logger.log:
          format: "Outdoor temperature changed to %.1f."
          args: [ 'id(outdoor_temp).state' ]
      - script.execute:
          id: update_max_throttled_humid
          indoor_temp: !lambda "return float(id(indoor_temp).state);"
          outdoor_temp: !lambda "return float(x);"
          r_val: !lambda "return float(id(r_value).state);"

  - platform: homeassistant
    id: familyroom_temp
    entity_id: sensor.esp32_familyroom_env_temperature
  - platform: homeassistant
    id: familyroom_humid
    entity_id: sensor.esp32_familyroom_env_humidity

  - platform: homeassistant
    id: diningroom_temp
    entity_id: sensor.esp_dining_room_env_temperature
  - platform: homeassistant
    id: diningroom_humid
    entity_id: sensor.esp_dining_room_env_humidity

  # Combined temperature (ESPHome 2025.9+)
  - platform: combination
    type: kalman
    name: "Household Temperature"
    id: indoor_temp
    device_class: "temperature"
    state_class: "measurement"
    unit_of_measurement: "°F"
    process_std_dev: 0.060
    sources:
      - source: familyroom_temp
        error: 1.0
      - source: diningroom_temp
        error: 1.0
    on_value:
      - logger.log:
          format: "Indoor temperature changed to %.1f."
          args: [ 'id(indoor_temp).state' ]
      - script.execute:
          id: update_max_throttled_humid
          indoor_temp: !lambda "return float(x);"
          outdoor_temp: !lambda "return float(id(outdoor_temp).state);"
          r_val: !lambda "return float(id(r_value).state);"

  # Combined humidity
  - platform: combination
    type: kalman
    name: "Household Humidity"
    id: indoor_humid
    device_class: "humidity"
    state_class: "measurement"
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    process_std_dev: 0.060
    sources:
      - source: familyroom_humid
        error: 1.0
      - source: diningroom_humid
        error: 1.0
    on_value:
      - logger.log:
          format: "Household humidity changed to %.1f."
          args: [ 'id(indoor_humid).state' ]
      - script.execute:
          id: eval_humid
          current_humid: !lambda "return float(x);"
    filters:
      - filter_out: nan
      - round: 0
      - lambda: !lambda "return int(x);"

# ------------- Text sensors -------------
text_sensor:
  - platform: template
    name: "Humidifier Status"
    id: humidifier_status
    icon: "mdi:air-humidifier"

  - platform: homeassistant
    id: fan_mode
    entity_id: climate.main_floor
    attribute: fan_mode
    on_value:
      then:
        - lambda: |-
            bool is_on = (x == "on");
            id(fan_running).publish_state(is_on);
        - if:
            condition:
              and:
                - text_sensor.state: { id: humidifier_status, state: "on" }
                - lambda: 'return x != "on";'
            then:
              - logger.log: "Fan turned off while steaming; performing safe shutdown."
              - script.execute: shutdown_steam_and_fan_runout

  - platform: homeassistant
    id: heat_mode
    entity_id: climate.main_floor
    on_value:
      then:
        - lambda: |-
            if ( (x == "heat" || x == "heat_cool") || (id(require_heat).state == false) ){
              id(heat_mode_satisfied).publish_state(true);
            } else {
              id(heat_mode_satisfied).publish_state(false);
            }

# ------------- Scripts -------------
script:
  - id: eval_humid
    parameters:
      current_humid: float
    then:
      - if:
          condition:
            and:
              - binary_sensor.is_on: heat_mode_satisfied
              - lambda: |-
                  float low = id(humid_setpoint_adjusted).state - (id(humid_hysteresis).state / 2.0f);
                  return int(current_humid) <= int(low);
              - text_sensor.state: { id: humidifier_status, state: 'off' }
          then:
            - logger.log: "Need to turn ON the steam!"
            - button.press: toggle_steam
      - if:
          condition:
            and:
              - lambda: |-
                  float high = id(humid_setpoint_adjusted).state + (id(humid_hysteresis).state / 2.0f);
                  return int(current_humid) >= int(high);
              - text_sensor.state: { id: humidifier_status, state: 'on' }
          then:
            - logger.log: "Need to turn OFF the steam!"
            - button.press: toggle_steam

  - id: update_max_throttled_humid
    parameters:
      indoor_temp: float
      outdoor_temp: float
      r_val: float
    then:
      - lambda: |-
          double indoor_temp_c = 5.0/9.0 * (indoor_temp - 32.0);
          double outdoor_temp_c = 5.0/9.0 * (outdoor_temp - 32.0);

          ESP_LOGD("lambda", "indoor_temp_c: %f | outdoor_temp_c: %f | r_val: %f",
                   indoor_temp_c, outdoor_temp_c, r_val);

          auto publish_adjusted = [&](int adjusted) {
            if (adjusted < 0) adjusted = 0;
            if (adjusted > 100) adjusted = 100;
            id(humid_setpoint_adjusted).publish_state(adjusted);
            ESP_LOGD("lambda", "Adjusted humidity setpoint -> %d %%", adjusted);
          };

          if (isnan(indoor_temp_c) || isnan(outdoor_temp_c) || isnan(r_val)) {
            ESP_LOGE("lambda", "Temp and/or R-value is NaN. Throttling to 0.");
            publish_adjusted(0);
            return;
          }

          if (r_val < 0.1) { ESP_LOGW("lambda", "r_val too low (%.3f). Clamping to 0.1.", r_val); r_val = 0.1; }
          if (r_val > 1000.0) { ESP_LOGW("lambda", "r_val unrealistically high (%.1f). Clamping.", r_val); r_val = 1000.0; }

          int user_sp = int(id(humid_setpoint).state);
          if (user_sp < 0) user_sp = 0;
          if (user_sp > 100) user_sp = 100;

          if (id(avoid_condensation).state) {
            double T_surface = indoor_temp_c - (indoor_temp_c - outdoor_temp_c) / r_val;
            double rh_at_condense = calc_relative_humidity(indoor_temp_c, T_surface);

            int h_buffer = int(round(id(humid_hysteresis).state / 2.0));
            int humid_limit = int(rh_at_condense) - h_buffer;

            if (humid_limit < 0) humid_limit = 0;
            if (humid_limit > 100) humid_limit = 100;

            int adjusted = (humid_limit <= user_sp) ? humid_limit : user_sp;
            publish_adjusted(adjusted);

            ESP_LOGD("lambda", "THROTTLED: setpoint_adj=%d (limit=%d, user=%d, buffer=%d)",
                     adjusted, humid_limit, user_sp, h_buffer);
          } else {
            ESP_LOGD("lambda", "UNTHROTTLED: using user setpoint %d", user_sp);
            publish_adjusted(user_sp);
          }

  # Safe shutdown. If HA is offline at the end of run-out, defer the fan restore.
  - id: shutdown_steam_and_fan_runout
    then:
      - if:
          condition:
            or:
              - text_sensor.state: { id: humidifier_status, state: "on" }
              - text_sensor.state: { id: humidifier_status, state: "starting" }
          then:
            - text_sensor.template.publish:
                id: humidifier_status
                state: "stopping"
            - switch.turn_off: call_humid
            - logger.log: "Waiting 10 mins to turn off furnace fan..."
            - delay: 10min
            - if:
                condition:
                  binary_sensor.is_on: ha_connected
                then:
                  - homeassistant.service:
                      service: climate.set_fan_mode
                      data:
                        entity_id: climate.main_floor
                        fan_mode: !lambda 'return id(prev_fan_mode).c_str();'
                  - logger.log: "Furnace fan mode restored."
                else:
                  - logger.log: "HA still offline; deferring fan-mode restore."
                  - lambda: 'id(restore_fan_pending) = true;'
      - text_sensor.template.publish:
          id: humidifier_status
          state: "off"

# ------------- Packages -------------
packages:
  basic: !include common/basic.yaml
  bme680: !include common/bme680.yaml
